<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Execution Context && Scop chain | ddinnis' Site</title><meta name=keywords content="Note"><meta name=description content="这是一篇关于执行上下文(Execution Context) && 作用域链(Scop chain)的笔记。"><meta name=author content="ddinnis"><link rel=canonical href=https://ddinnis.github.io/posts/execution-context-scop-chain/><meta name=google-site-verification content="lz4VrU2w2dij-Aa8DVgIc_GVLGZ3zyTh_kLL7s_B470"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.min.fc4db75d62bf41fe3bbf24762652a7be515ec1110c48a34125ee22951789c4e2.css integrity="sha256-/E23XWK/Qf47vyR2JlKnvlFewREMSKNBJe4ilReJxOI=" rel="preload stylesheet" as=style><link rel=preload href=/apple-touch-icon.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ddinnis.github.io/%3Clink%20/%20absolute%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://ddinnis.github.io/%3Clink%20/%20absolute%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ddinnis.github.io/%3Clink%20/%20absolute%20url%3E><link rel=apple-touch-icon href=https://ddinnis.github.io/%3Clink%20/%20absolute%20url%3E><link rel=mask-icon href=https://ddinnis.github.io/%3Clink%20/%20absolute%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Execution Context && Scop chain"><meta property="og:description" content="这是一篇关于执行上下文(Execution Context) && 作用域链(Scop chain)的笔记。"><meta property="og:type" content="article"><meta property="og:url" content="https://ddinnis.github.io/posts/execution-context-scop-chain/"><meta property="og:image" content="https://ddinnis.github.io/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-04-16T22:13:56+08:00"><meta property="article:modified_time" content="2022-04-16T22:13:56+08:00"><meta property="og:site_name" content="ddinnis' Site"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ddinnis.github.io/%3Cimage%20path/url%3E"><meta name=twitter:title content="Execution Context && Scop chain"><meta name=twitter:description content="这是一篇关于执行上下文(Execution Context) && 作用域链(Scop chain)的笔记。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://ddinnis.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Execution Context \u0026\u0026 Scop chain","item":"https://ddinnis.github.io/posts/execution-context-scop-chain/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Execution Context \u0026\u0026 Scop chain","name":"Execution Context \u0026\u0026 Scop chain","description":"这是一篇关于执行上下文(Execution Context) \u0026amp;\u0026amp; 作用域链(Scop chain)的笔记。\n","keywords":["Note"],"articleBody":"这是一篇关于执行上下文(Execution Context) \u0026\u0026 作用域链(Scop chain)的笔记。\nExecution Context 词法环境(Lexical environment) 有两个功能：\n  环境记录 (environment record) : 储存变量和函数声明\n 是一种 标识符-变量映射(identifier-variable mapping) 的结构。  标识符(identifier)：变量/函数（variable/function）的名称 变量(value)：是对对象（object）或原始值（primitive）的引用。\\      指向外界: outer (reference to the outer(parent) environment)\nlexicalEnvironment = {  environmentRecord: {  identifier : value,  identifier : value  }  outer:  thisBinding：取决于运行所在地 } Code:\nvar apple = 10; function foo() {  var banana = 20;  console.log('foo'); } foo(); GlobalLexicalEnvironment = {  environmentRecord: {  apple : '10',  foo : function object   }  outer: null }  FunctionLexicalEnvironment = {  environmentRecord: {  banana : 20,  }  outer: globalLexicalEnvironment } ​\n  变量环境(Variable environments)  The LexicalEnvironment and VariableEnvironment components of an execution context are always Lexical Environments. When an execution context is created its LexicalEnvironment and VariableEnvironment components initially have the same value. The value of the VariableEnvironment component never changes while the value of the LexicalEnvironment component may change during execution of code within an execution context.\n https://262.ecma-international.org/5.1/#sec-10.3\n从中可知LexicalEnvironment 和 VariableEnvironment指向的都是Lexical Environments。\n执行上下文(Execution context)  执行JavaScript代码的环境  执行上下文的种类：  全局执行上下文（Global Execution Context / GEC）  最基本的Excution Context，且只有一个 当代码加载时，默认进入的执行环境 创建一个内存堆来存储variables和function的引用地址 variables的最初值皆为”undefined”   函数执行上下文（Function Execution Context / FEC）  可以有多个 每当调用一个函数时，会新建一个函数执行上下文。    执行上下文分为两个阶段：   创建阶段\n  执行阶段\n创建阶段： ​\tJS Engine 会解析代码，对代码中的var变量和函数提升到代码顶层，并开辟空间进行储存，所有的var变量初始值皆为undefined，所以可以在声明之前被引用。\n​\t这就会引出变量提升(Hoisting)的问题：\nconsole.log(apple); // undefined foo(); // foo  var apple = 10; function foo() {  console.log('foo'); } ​\tconsole.log(apple) 的结果为 undefined 就是因为变量声明，在执行第一行代码时 apple = undefined ，直到第三行 var apple = 10 时 apple 才会被赋值于10变量提升的规则：\n 作用于var，会被初始化为undefined 对于let const，不会被初始化有默认值，所以会报错: ·ReferenceError : is not defined  ​\n创建作用域链（The Scope Chain） 当JS引擎在自己的环境里找不到所要的变量时，就会在外界环境（outer environment）中寻找，也就是词法环境中的outer, 直到找到为止。但是外部作用域不能作用于内部函数\n  找到 identifier，则返回值或引用，若没有赋值就返回 undefined\n  未找到 identifier，则返回报错并打印Uncaught ReferenceError:  is not defined\n  ​\n执行阶段： 执行堆栈 (Execution Stack)  堆栈是存储以后进先出（LIFO）形式的值的数据结构 当函数执行调用时，都会从堆栈中移除，但是其词法环境是否从内存中释放，取决于其是否被其它词法环境的 outer 引用 每当调用一个新的函数时，就会新建一个Execution Context放到Execution Context Stack的顶端     Example Code Example 1 var apple = 10; var banana = 20;  function foo() {  console.log('foo'); }  function bar() { \tvar num = 3  console.log('bar'); \tfoo() }  bar() //Output: //bar //foo 对于变量来说，在编译的时候JS引擎会会将变量的值初始化为“undefined”，直到开始执行到变量值的那一行代码，才会将真正的值赋值给变量\nCode Example 2 function b(){  var myvar  console.log(myvar) }  function a(){  var myvar = 2  console.log(myvar)  b() } var myvar = 1 console.log(myvar) a() console.log(myvar) 编译的时候，Global Object中会存储有变量和函数，变量的值为\"undefined\"，函数则指向此函数所在的位置\n Reference    Understanding Execution Context and Execution Stack in Javascript\n  JavaScript Execution Context - javatpoint\n  ECMAScript 5 spec: LexicalEnvironment versus VariableEnvironment\n  Understanding Scope and Scope Chain in JavaScript\n  ECMA-262-5 in detail. Chapter 3.2. Lexical environments: ECMAScript implementation.\n  ","wordCount":"1459","inLanguage":"en","image":"https://ddinnis.github.io/%3Cimage%20path/url%3E","datePublished":"2022-04-16T22:13:56+08:00","dateModified":"2022-04-16T22:13:56+08:00","author":[{"@type":"Person","name":"ddinnis"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://ddinnis.github.io/posts/execution-context-scop-chain/"},"publisher":{"@type":"Organization","name":"ddinnis' Site","logo":{"@type":"ImageObject","url":"https://ddinnis.github.io/%3Clink%20/%20absolute%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ddinnis.github.io/ accesskey=h title="ddinnis's Note (Alt + H)"><img src=https://ddinnis.github.io/apple-touch-icon.png alt=logo aria-label=logo height=35>ddinnis's Note</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ddinnis.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://ddinnis.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://ddinnis.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://ddinnis.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://ddinnis.github.io/archives/ title=Archives><span>Archives</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ddinnis.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ddinnis.github.io/posts/>Posts</a></div><h1 class=post-title>Execution Context && Scop chain</h1><div class=post-meta><span title="2022-04-16 22:13:56 +0800 CST">April 16, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;ddinnis</div></header><aside id=toc-container class="toc-container wide"><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#execution-context aria-label="Execution Context">Execution Context</a><ul><li><a href=#%e8%af%8d%e6%b3%95%e7%8e%af%e5%a2%83lexical-environment aria-label="词法环境(Lexical environment)">词法环境(Lexical environment)</a></li><li><a href=#%e5%8f%98%e9%87%8f%e7%8e%af%e5%a2%83variable-environments aria-label="变量环境(Variable environments)">变量环境(Variable environments)</a></li></ul></li><li><a href=#%e6%89%a7%e8%a1%8c%e4%b8%8a%e4%b8%8b%e6%96%87execution-context aria-label="执行上下文(Execution context)">执行上下文(Execution context)</a><ul><li><a href=#%e6%89%a7%e8%a1%8c%e4%b8%8a%e4%b8%8b%e6%96%87%e7%9a%84%e7%a7%8d%e7%b1%bb aria-label=执行上下文的种类：>执行上下文的种类：</a></li><li><a href=#%e6%89%a7%e8%a1%8c%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%86%e4%b8%ba%e4%b8%a4%e4%b8%aa%e9%98%b6%e6%ae%b5 aria-label=执行上下文分为两个阶段：>执行上下文分为两个阶段：</a><ul><li><a href=#%e5%88%9b%e5%bb%ba%e9%98%b6%e6%ae%b5 aria-label=创建阶段：>创建阶段：</a></li></ul></li><li><a href=#%e5%88%9b%e5%bb%ba%e4%bd%9c%e7%94%a8%e5%9f%9f%e9%93%bethe-scope-chain aria-label="创建作用域链（The Scope Chain）">创建作用域链（The Scope Chain）</a><ul><li><a href=#%e6%89%a7%e8%a1%8c%e9%98%b6%e6%ae%b5 aria-label=执行阶段：>执行阶段：</a></li><li><a href=#%e6%89%a7%e8%a1%8c%e5%a0%86%e6%a0%88-execution-stack aria-label="执行堆栈 (Execution Stack)">执行堆栈 (Execution Stack)</a></li></ul></li></ul></li><li><a href=#example aria-label=Example>Example</a><ul><li><a href=#code-example-1 aria-label="Code Example 1">Code Example 1</a></li><li><a href=#code-example-2 aria-label="Code Example 2">Code Example 2</a></li></ul></li><li><a href=#reference aria-label=Reference>Reference</a></li></ul></div></details></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const e=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${e}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>这是一篇关于执行上下文(Execution Context) && 作用域链(Scop chain)的笔记。</p><h2 id=execution-context>Execution Context<a hidden class=anchor aria-hidden=true href=#execution-context>#</a></h2><h3 id=词法环境lexical-environment>词法环境(Lexical environment)<a hidden class=anchor aria-hidden=true href=#词法环境lexical-environment>#</a></h3><p>有两个功能：</p><ul><li><p>环境记录 <strong>(environment record)</strong> : 储存变量和函数声明</p><ul><li>是一种 <strong>标识符-变量映射(identifier-variable mapping)</strong> 的结构。<ul><li>标识符(identifier)：变量/函数（variable/function）的名称</li><li>变量(value)：是对对象（object）或原始值（primitive）的引用。\</li></ul></li></ul></li><li><p>指向外界: outer <strong>(reference to the outer(parent) environment)</strong></p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>lexicalEnvironment = {
</span></span><span style=display:flex><span>  environmentRecord: {
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>identifier</span>&gt; : &lt;<span style=font-weight:700>value</span>&gt;,
</span></span><span style=display:flex><span>    &lt;<span style=font-weight:700>identifier</span>&gt; : &lt;<span style=font-weight:700>value</span>&gt;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  outer: &lt; Reference to the parent lexical environment&gt;
</span></span><span style=display:flex><span>  thisBinding<span style=color:red>：</span>取决于运行所在地
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Code:</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> apple = <span style=color:#ff0;font-weight:700>10</span>;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> foo() {
</span></span><span style=display:flex><span>  <span style=color:#fff;font-weight:700>var</span> banana = <span style=color:#ff0;font-weight:700>20</span>;
</span></span><span style=display:flex><span>  console.log(<span style=color:#0ff;font-weight:700>&#39;foo&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>foo();
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>GlobalLexicalEnvironment = {
</span></span><span style=display:flex><span>  environmentRecord: {
</span></span><span style=display:flex><span>      apple : <span style=color:#0ff;font-weight:700>&#39;10&#39;</span>,
</span></span><span style=display:flex><span>      foo : &lt; reference to <span style=color:#fff;font-weight:700>function</span> object &gt;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  outer: <span style=color:#fff;font-weight:700>null</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FunctionLexicalEnvironment = {
</span></span><span style=display:flex><span>  environmentRecord: {
</span></span><span style=display:flex><span>      banana : <span style=color:#ff0;font-weight:700>20</span>,
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  outer: &lt;<span style=font-weight:700>globalLexicalEnvironment</span>&gt;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>​</p></li></ul><h3 id=变量环境variable-environments>变量环境(Variable environments)<a hidden class=anchor aria-hidden=true href=#变量环境variable-environments>#</a></h3><blockquote><p>The LexicalEnvironment and VariableEnvironment components of an execution context are always Lexical Environments. When an execution context is created its LexicalEnvironment and VariableEnvironment components initially have the same value. The value of the VariableEnvironment component <strong>never changes</strong> while the value of the LexicalEnvironment component <strong>may change</strong> during execution of code within an execution context.</p></blockquote><p><a href=https://262.ecma-international.org/5.1/#sec-10.3>https://262.ecma-international.org/5.1/#sec-10.3</a></p><p>从中可知LexicalEnvironment 和 VariableEnvironment指向的都是Lexical Environments。</p><h2 id=执行上下文execution-context>执行上下文(Execution context)<a hidden class=anchor aria-hidden=true href=#执行上下文execution-context>#</a></h2><ul><li>执行JavaScript代码的环境</li></ul><h3 id=执行上下文的种类>执行上下文的种类：<a hidden class=anchor aria-hidden=true href=#执行上下文的种类>#</a></h3><ul><li>全局执行上下文（Global Execution Context / GEC）<ul><li>最基本的Excution Context，且只有一个</li><li>当代码加载时，默认进入的执行环境</li><li>创建一个内存堆来存储variables和function的引用地址</li><li>variables的最初值皆为”<strong>undefined</strong>”</li></ul></li><li>函数执行上下文（Function Execution Context / FEC）<ul><li>可以有多个</li><li>每当调用一个函数时，会新建一个函数执行上下文。</li></ul></li></ul><h3 id=执行上下文分为两个阶段>执行上下文分为两个阶段：<a hidden class=anchor aria-hidden=true href=#执行上下文分为两个阶段>#</a></h3><ul><li><p>创建阶段</p></li><li><p>执行阶段</p><h4 id=创建阶段>创建阶段：<a hidden class=anchor aria-hidden=true href=#创建阶段>#</a></h4><p>​ JS Engine 会解析代码，对代码中的<code>var</code>变量和函数提升到代码顶层，并开辟空间进行储存，所有的<code>var</code>变量初始值皆为<code>undefined</code>，所以可以在声明之前被引用。</p><p>​ 这就会引出变量提升(<code>Hoisting</code>)的问题：</p><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span>console.log(apple); <span style=color:#007f7f>// undefined
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>foo();              <span style=color:#007f7f>// foo
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> apple = <span style=color:#ff0;font-weight:700>10</span>;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> foo() {
</span></span><span style=display:flex><span>  console.log(<span style=color:#0ff;font-weight:700>&#39;foo&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>​ <code>console.log(apple)</code> 的结果为 <code>undefined</code> 就是因为变量声明，在执行第一行代码时 <code>apple = undefined</code> ，直到第三行 <code>var apple = 10</code> 时 <code>apple</code> 才会被赋值于<code>10</code>
变量提升的规则：</p><ul><li>作用于<code>var</code>，会被初始化为<code>undefined</code></li><li>对于<code>let</code> <code>const</code>，不会被初始化有默认值，所以会报错: ·ReferenceError : is not defined</li></ul><p>​</p><h3 id=创建作用域链the-scope-chain>创建作用域链（The Scope Chain）<a hidden class=anchor aria-hidden=true href=#创建作用域链the-scope-chain>#</a></h3><p>当JS引擎在自己的环境里找不到所要的变量时，就会在外界环境（outer environment）中寻找，也就是词法环境中的outer, 直到找到为止。但是外部作用域不能作用于内部函数</p><ul><li><p>找到 identifier，则返回值或引用，若没有赋值就返回 <code>undefined</code></p></li><li><p>未找到 identifier，则返回报错并打印<code>Uncaught ReferenceError: &lt;identified> is not defined</code></p><p><img loading=lazy src=/img/scope.png alt=scope></p></li></ul><p>​</p><h4 id=执行阶段>执行阶段：<a hidden class=anchor aria-hidden=true href=#执行阶段>#</a></h4><h4 id=执行堆栈-execution-stack>执行堆栈 (Execution Stack)<a hidden class=anchor aria-hidden=true href=#执行堆栈-execution-stack>#</a></h4><ul><li>堆栈是存储以后进先出（LIFO）形式的值的数据结构</li><li>当函数执行调用时，都会从堆栈中移除，但是其词法环境是否从内存中释放，取决于其是否被其它词法环境的 <code>outer</code> 引用</li><li>每当调用一个新的函数时，就会新建一个Execution Context放到Execution Context Stack的顶端</li></ul><p><img loading=lazy src=/img/execute-context-stack.png alt=execute-context-stack.png></p></li></ul><hr><h2 id=example>Example<a hidden class=anchor aria-hidden=true href=#example>#</a></h2><h3 id=code-example-1>Code Example 1<a hidden class=anchor aria-hidden=true href=#code-example-1>#</a></h3><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> apple = <span style=color:#ff0;font-weight:700>10</span>;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> banana = <span style=color:#ff0;font-weight:700>20</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> foo() {
</span></span><span style=display:flex><span>  console.log(<span style=color:#0ff;font-weight:700>&#39;foo&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> bar() {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>var</span> num = <span style=color:#ff0;font-weight:700>3</span>
</span></span><span style=display:flex><span>  console.log(<span style=color:#0ff;font-weight:700>&#39;bar&#39;</span>);
</span></span><span style=display:flex><span>	foo()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bar()
</span></span><span style=display:flex><span><span style=color:#007f7f>//Output:
</span></span></span><span style=display:flex><span><span style=color:#007f7f>//bar
</span></span></span><span style=display:flex><span><span style=color:#007f7f>//foo
</span></span></span></code></pre></div><p><img loading=lazy src=/img/step1.png alt=step1></p><p>对于变量来说，在编译的时候JS引擎会会将变量的值初始化为“undefined”，直到开始执行到变量值的那一行代码，才会将真正的值赋值给变量</p><p><img loading=lazy src=/img/step2.png alt=step2></p><p><img loading=lazy src=/img/step3.png alt=step3></p><p><img loading=lazy src=/img/step4.png alt=step4></p><h3 id=code-example-2>Code Example 2<a hidden class=anchor aria-hidden=true href=#code-example-2>#</a></h3><div class=highlight><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> b(){
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>var</span> myvar
</span></span><span style=display:flex><span>    console.log(myvar)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> a(){
</span></span><span style=display:flex><span>    <span style=color:#fff;font-weight:700>var</span> myvar = <span style=color:#ff0;font-weight:700>2</span>
</span></span><span style=display:flex><span>    console.log(myvar)
</span></span><span style=display:flex><span>    b()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> myvar = <span style=color:#ff0;font-weight:700>1</span>
</span></span><span style=display:flex><span>console.log(myvar)
</span></span><span style=display:flex><span>a()
</span></span><span style=display:flex><span>console.log(myvar)
</span></span></code></pre></div><p><img loading=lazy src=/img/chain_step1.png alt=chain_step1.png>
编译的时候，Global Object中会存储有变量和函数，变量的值为"undefined"，函数则指向此函数所在的位置</p><p><img loading=lazy src=/img/chain_step2.png alt=chain_step2.png></p><p><img loading=lazy src=/img/chain_step3.png alt=chain_step3.png></p><hr><h2 id=reference>Reference<a hidden class=anchor aria-hidden=true href=#reference>#</a></h2><blockquote><ol><li><p><a href=https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0>Understanding Execution Context and Execution Stack in Javascript</a></p></li><li><p><a href="https://www.javatpoint.com/javascript-execution-context#:~:text=Execution%20context%20is%20the%20concept%20for%20describing%20the,functions%2C%20variables%2C%20and%20objects%20used%20in%20the%20code.">JavaScript Execution Context - javatpoint</a></p></li><li><p><a href=https://2ality.com/2011/04/ecmascript-5-spec-lexicalenvironment.html>ECMAScript 5 spec: LexicalEnvironment versus VariableEnvironment</a></p></li><li><p><a href=https://blog.bitsrc.io/understanding-scope-and-scope-chain-in-javascript-f6637978cf53>Understanding Scope and Scope Chain in JavaScript</a></p></li><li><p><a href=http://dmitrysoshnikov.com/ecmascript/es5-chapter-3-2-lexical-environments-ecmascript-implementation/>ECMA-262-5 in detail. Chapter 3.2. Lexical environments: ECMAScript implementation.</a></p></li></ol></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://ddinnis.github.io/tags/note/>Note</a></li></ul><nav class=paginav><a class=prev href=https://ddinnis.github.io/posts/this/><span class=title>« Prev Page</span><br><span>this</span></a>
<a class=next href=https://ddinnis.github.io/posts/prototype-vs-__proto__/><span class=title>Next Page »</span><br><span>Prototype vs __Proto__</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://ddinnis.github.io/>ddinnis' Site</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(t=>{const n=t.parentNode.parentNode,e=document.createElement("button");e.classList.add("copy-code"),e.innerText="copy";function s(){e.innerText="copied!",setTimeout(()=>{e.innerText="copy"},2e3)}e.addEventListener("click",o=>{if("clipboard"in navigator){navigator.clipboard.writeText(t.textContent),s();return}const e=document.createRange();e.selectNodeContents(t);const n=window.getSelection();n.removeAllRanges(),n.addRange(e);try{document.execCommand("copy"),s()}catch(e){}n.removeRange(e)}),n.classList.contains("highlight")?n.appendChild(e):n.parentNode.firstChild==n||(t.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?t.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(e):t.parentNode.appendChild(e))})</script></body></html>