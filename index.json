[{"content":"Tenzies GITHUB: https://github.com/ddinnis/tenzies\n 这是一个 Demo   FreeCodeCamp GITHUB: https://github.com/ddinnis/freecodecamp\n Tribute Page Survey Form Product Landing Page Technical Documentation Page Personal Portfolio   Web Development Bootcamp by Angela GITHUB: https://github.com/ddinnis/Web-Development-Bootcamp-by-Angela\n Dicee Drum Kit My Site TinDog  ","permalink":"https://ddinnis.github.io/projects/","summary":"Tenzies GITHUB: https://github.com/ddinnis/tenzies 这是一个 Demo FreeCodeCamp GITHUB: https://github.com/ddinnis/freecodecamp Tribute Page Survey Form Product Landing Page Technical Documentation Page Personal Portfolio Web Development Bootcamp by Angela GITHUB: https://github.com/ddinnis/Web-Development-Bootcamp-by-Angela Dicee Drum Kit My Site TinDog","title":"Projects 🤹‍♂️"},{"content":"JavaScript目前有三个关键字来声明变量，即var, let, const。 在ES6之前只有一种方法 var 来申明变量，ES6后新添了 let 和 const 声明变量。\nVar (global and function scope):  全局作用域，会在window上添加属性 可以再次声明 可以重新赋值 在函数内定义时，作用域是函数内部，在函数外定义时，作用域为全局 在任何变量被执行前，会对var进行变量提升（hosting），初始值为 undefined   变量提升（hosting）：意味着可以在定义一个变量在未声明前\n // 全局作用域  var name = \u0026#34;John Doe\u0026#34;; function logName() {  console.log(name); };  logName(); // John Doe // Window {window: Window, self: Window, document: document, name: \u0026#39;John Doe\u0026#39;, location: Location, …} // 在函数内定义时，作用域是函数内部  function logName() {  var name = \u0026#34;John Doe\u0026#34;;  var id = 1;  console.log(name); };  function logId() {  console.log(id); }  logId(); // ReferenceError: id is not defined // 在执行logId函数的时候，id没有在logId函数内定义 // 所以在全局变量中寻找id变量，也没有 // 所以是undefined // 在函数外定义时，作用域为全局  var name = \u0026#34;John Doe\u0026#34;; if (true) {  var name = \u0026#34;Daniel Joan\u0026#34;; }  console.log(name); // Daniel Joan // 当在{}大括号中定义var时 // name的值会被重写，指向\u0026#34;Daniel Joan\u0026#34; // 变量提升  function logName() {  console.log(name);  var name = \u0026#34;John Doe\u0026#34;; };  logName(); // undefined let (block scope) 和 const (block scope)：  只有块级作用域，window无法访问 不可以再次声明 在变量声明之前，变量都是不可以访问的 不存在变量提升（解析阶段会被创建出来，但不能被访问）  二者的区别是：\n 需要重新分配变量的时候使用 let，例如：循环\n  不需要重新分配变量的时候使用 const，是constant（常数）的缩写 但是可以改变const对象的属性\n let name = \u0026#34;John\u0026#34;;  if(true){  let name = \u0026#34;Jane\u0026#34;;  console.log(name); }  console.log(name); // Jane // John // 这两个name变量是不同的变量，因为有着不同的作用域  function fn() {  if(true){  let name = \u0026#34;Jane\u0026#34;;  console.log(name);  }  console.log(name); // let是块级作用域，name在if代码块中定义 }  fn() // Jane // ReferenceError: name is not defined let 和 const是块级作用域\n{  const x = 2;  console.log(x); // 2 } console.log(x); // ReferenceError: x is not defined  {  let x = 2;  console.log(x); // 2 } console.log(x); let和const皆不可以再次声明\nlet name = \u0026#34;John\u0026#34;; let name = \u0026#34;Jane\u0026#34;; // SyntaxError: Identifier \u0026#39;name\u0026#39; has already been declared let name = \u0026#34;John\u0026#34;; name = \u0026#34;Jane\u0026#34;; // let可以重新赋值  const name = \u0026#34;John\u0026#34;; const name = \u0026#34;Jane\u0026#34;; // SyntaxError: Identifier \u0026#39;name\u0026#39; has already been declared const name = \u0026#34;John\u0026#34;; name = \u0026#34;Jane\u0026#34;; // TypeError: Assignment to constant variable. // const重新赋值不被允许 const不可以再次赋值，可以通过改变const对象的属性进行赋值\nconst fullName = {  firstName: \u0026#34;John\u0026#34;,  lastName: \u0026#34;Doe\u0026#34; } fullName.firstName = \u0026#34;Ellen\u0026#34; console.log(fullName) // { firstName: \u0026#39;Ellen\u0026#39;, lastName: \u0026#39;Doe\u0026#39; }  实际开发如何选择   首先排除var在let和const之间做选择，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。\n  在导入库（Libraries）的时候使用const\n  一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同.\n  Reference   The Difference Between var, let and const in JavaScript and Best Practices educative | Difference between var, let, and const keyword in JavaScript geeksforgeeks | Difference between var, let and const keywords in JavaScript On let vs const   ","permalink":"https://ddinnis.github.io/posts/varlet-and-const/","summary":"JavaScript目前有三个关键字来声明变量，即var, let, const。 在ES6之前只有一种方法 var 来申明变量，ES6后新添了 let 和 const 声明变量。","title":"var，let and const"},{"content":" 函数在调用时，JavaScripts会默认给this绑定一个值； this的绑定和定义的位置无关； this的绑定和调用方式以及调用的位置有关； this是在运行时被绑定的；  this的绑定方式:  默认绑定：通过函数进行调用，是独立函数，则this指向全局(global/window) 隐式绑定：通过方法进行调用，则this绑定到了所调用的对象上 显示绑定：可以指定绑定对象（bind call apply） 箭头函数（Arrow Function） 构造函数（new）  默认绑定  function foo() {  console.log(this) }  foo()//window 隐式绑定 var obj = {  name: \u0026#34;obj\u0026#34;,  foo: foo } function foo() {  console.log(this) }  obj.foo()//obj foo()绑定在obj对象上，this指向obj\nExample Code 1 function app(){  console.log(this)  this.appVaribale = \u0026#39;hello\u0026#39; }  app() //Window console.log(appVaribale) //hello console.log(app.appVaribale) //underfind ,appVaribale绑定到了window上 console.log(this) //window 调用app函数时，this指向window，运行 console.log(appVaribale) 代码时window增加了appVaribale对象，且值为 \u0026ldquo;hello\u0026rdquo;。与app函数无关，所以运行 console.log(app.appVaribale) 这行代码时JS引擎在app函数里面找不到appVaribale对象，则返回 undefined。\n显示绑定   bind: function.bind(thisArg[, arg1[, arg2[, ...]]])\n  call: function*.call(thisArg, arg1, arg2, ...)\n  apply: func*.apply(thisArg, [argsArray])\n  apply/call/bind: 当传入 null/undefined 时，自动将 this 绑定成全局对象\n  function add(c, d) {  console.log(this.a + this.b + c + d); } var num = {a: 1, b: 3};  add.call(num, 5, 7); // 16 add.apply(num, [10, 20]); // 34  add.call(undefined, 5, 7); // 16 add.apply(null, [10, 20]); // 34 箭头函数 箭头函数没有自己的this，都是从ParentScope继承的\nvar title = \u0026#34;window\u0026#34; const video = {  title: \u0026#39;a\u0026#39;,  play: function() {  return () =\u0026gt; {  console.log(this.title)  }  } };  var fn1 = video.play(); fn1()//a  var fn2 = video.play; fn2()()//window  调用video.play函数赋值给了fn1，fn1是一个箭头函数\n() =\u0026gt; { console.log(this.title) } ，这个箭头函数的this是从ParentScope 处继承来的，video.tilte = \u0026ldquo;a\u0026rdquo;。 引用video.plya函数，fn2是一个匿名函数调用后返回一个箭头函数\n () { return () =\u0026gt; { console.log(this.title) } }，调用箭头函数后，this指向window,因为它从上层作用域 play 继承了this。  构造函数（new） this 被绑定到正在构造的新对象\nfunction Video(title) {  console.log(this)  this.title = title }  var video = new Video(\u0026#34;a\u0026#34;) 绑定优先级 new绑定 \u0026gt; 显示绑定(bind()\u0026gt;call() / apply()) \u0026gt; 隐式绑定(obj.foo()) \u0026gt;默认绑定（独立函数调用）\n练习题 习题来自于： 跟着coderwhy学习JavaScript高级（四） - 掘金 (juejin.cn)\nvar name = \u0026#34;window\u0026#34; var person = {  name: \u0026#34;person\u0026#34;,  sayName: function () {  console.log(this.name)  } };  function sayName() {  var sss = person.sayName;  sss() //window  person.sayName(); //person  (person.sayName)(); //My Mistake === person.sayName();  (b = person.sayName)(); //window }  sayName()  sss() : person.sayName为function () {console.log(this.name)} 赋值给 sss ,当调用 sss 函数时, 相当于函数独立调用(默认绑定), 指向window person.sayName() : 通过person调用(隐式绑定) (person.sayName)() : 等价于person.sayName() ,与sss() 不同的是, person.sayName 赋值给了新的变量sss . (b = person.sayName)() : 等价于sss()   var name = \u0026#34;window\u0026#34; var person1 = {  name: \u0026#34;person1\u0026#34;,  foo1: function () {  console.log(this.name)  },  foo2: () =\u0026gt; console.log(this.name),  foo3: function() {  return function() {  console.log(this.name)  }  },  foo4: function() {  return () =\u0026gt; {  console.log(this.name)  }  } };  var person2 = {name: \u0026#39;person2\u0026#39;}  person1.foo1(); //person1 person1.foo1.call(person2) //person2  person1.foo2(); //window,上层作用域是全局 person1.foo2.call(person2) //window foo2为箭头函数优先级\u0026gt;call/bind/apply  person1.foo3()(); //window独立函数调用，(person.foo3())() person1.foo3.call(person2)() //window person1.foo3().call(person2) //person2  person1.foo4()(); //person1,返回的箭头函数指向上层foo4函数指向person1 person1.foo4.call(person2)() //person2 person1.foo4().call(person2) //person1 person1.foo1() : 隐式绑定 person1.foo1.call(person2) : 显示绑定, 通过 call() 绑定到了person2上\nperson1.foo2() : 箭头函数要注意, 箭头函数本身没有 this 值, this值是从上层作用域(parentScope)继承而来的, foo2的上层作用域是window.\n 💡 注意person1 是一个对象而非函数, 所以foo2 的上层作用域不是person1\n person1.foo2.call(person2) : 箭头函数优先级 \u0026gt; 显示绑定( call/bind/apply )\nperson1.foo3()() : 等价于(person1.foo3())() , 独立函数调用(默认绑定) person1.foo3.call(person2)() : 等价于 (person1.foo3.call(person2))() , 独立函数调用(默认绑定) person1.foo3().call(person2) : 最后调用的函数绑定到了person2(显示绑定)\nperson1.foo4()() : 返回的箭头函数指向上层 foo4 函数指向person1 person1.foo4.call(person2)() : 返回的箭头函数指向上层foo4函数指向person2 person1.foo4().call(person2) : 返回的箭头函数指向上层foo4函数指向person1\n 💡 箭头函数自身没有 this 值, this值是从上层作用域(parentScope)继承而来的\n  var name = \u0026#39;window\u0026#39;  function Person(name) {  this.name = name;  this.obj = {  name: \u0026#39;obj\u0026#39;,  foo1: function () {  return function () {  console.log(this.name)  }  },  foo2: function () {  return () =\u0026gt; {  console.log(this.name)  }  }  }  }   var person1 = new Person(\u0026#39;person1\u0026#39;)  var person2 = new Person(\u0026#39;person2\u0026#39;)   person1.obj.foo1()() //window  person1.obj.foo1.call(person2)() //window  person1.obj.foo1().call(person2) //person2   person1.obj.foo2()() //obj  person1.obj.foo2.call(person2)() //person2  person1.obj.foo2().call(person2) //obj   person1.obj.foo1()() : 独立函数(默认绑定)\n  person1.obj.foo1.call(person2)() : 相当于 (person1.obj.foo1.call(person2))() 也是独立函数\n  person1.obj.foo1().call(person2) : 显示绑定, 绑定到了person2 上\n  person1.obj.foo2()() : 相当于 (person1.obj.foo2())() , 返回了一个箭头函数后调用它, 箭头函数的 this 继承于上层作用域 foo2 .\n  person1.obj.foo2.call(person2)() : 与person1.obj.foo2()() 类似, 但上层作用域 foo2 的this 被绑定到了 person1 上.\n  person1.obj.foo2().call(person2) : 返回的箭头函数指向上层 foo2 的 this 指向person2\n   Reference  MDN | this\n深入理解js this绑定\n跟着coderwhy学习JavaScript高级（四）\n ","permalink":"https://ddinnis.github.io/posts/this/","summary":"函数在调用时，JavaScripts会默认给this绑定一个值； this的绑定和定义的位置无关； this的绑定和调用方式以及调用的位置有关；","title":"this"},{"content":"这是一篇关于执行上下文(Execution Context) \u0026amp;\u0026amp; 作用域链(Scop chain)的笔记，参考了其它视频和博客资料。如有错误，欢迎指正。\nExecution Contest 词法环境(Lexical environment) 有两个功能：\n  环境记录 (environment record) : 储存变量和函数声明\n 是一种 标识符-变量映射(identifier-variable mapping) 的结构。  标识符：变量/函数（variable/function）的名称 变量：是对对象（object）或原始值（primitive）的引用。\n比如：  var apple = 10; var banana = 20;     指向外界: outer (reference to the outer(parent) environment)\n  变量环境(Variable environments)  The LexicalEnvironment and VariableEnvironment components of an execution context are always Lexical Environments. When an execution context is created its LexicalEnvironment and VariableEnvironment components initially have the same value. The value of the VariableEnvironment component never changes while the value of the LexicalEnvironment component may change during execution of code within an execution context.\n https://262.ecma-international.org/5.1/#sec-10.3\n从中可知LexicalEnvironment 和 VariableEnvironment指向的都是Lexical Environments。\n执行上下文(Execution context)  就是执行JavaScript代码的环境  执行上下文的种类：  全局执行上下文（Global Execution Context / GEC / Default Context）  最基本的Excution Context，且只有一个 当代码加载时，默认进入的执行环境 创建一个内存堆来存储variables和function的引用地址 variables的最初值皆为”undefined”   函数执行上下文（Functional Execution Context/FEC）  可以有多个 每当调用一个函数时，会新建一个函数执行上下文。   Eval Execution Context  Eval函数很少被使用，也是执行上下文的一部分    执行堆栈 (Execution Stack)  堆栈是存储以后进先出（LIFO）形式的值的数据结构 每当调用一个新的函数时，就会新建一个Execution Context放到Execution Context Stack的顶端   作用域链（The Scope Chain） 当JS引擎在自己的环境里找不到所要的变量时，就会在外界环境（outer environment）中寻找，也就是图中的outer, 直到找到为止。由前面可知，词法环境中的 标识符-变量映射(identifier-variable mapping)\n 找到 identifier，则返回值或引用，若没有赋值就返回 undefined 未找到 identifier，则返回报错并打印Uncaught ReferenceError: \u0026lt;identified\u0026gt; is not defined   Example Code Example 1 var apple = 10; var banana = 20;  function foo() {  console.log(\u0026#39;foo\u0026#39;); }  function bar() { \tvar num = 3  console.log(\u0026#39;bar\u0026#39;); \tfoo() }  bar() //Output: //bar //foo 对于变量来说，在编译的时候JS引擎会会将变量的值初始化为“undefined”，直到开始执行到变量值的那一行代码，才会将真正的值赋值给变量\nCode Example 2 function b(){  var myvar  console.log(myvar) }  function a(){  var myvar = 2  console.log(myvar)  b() } var myvar = 1 console.log(myvar) a() console.log(myvar) 编译的时候，Global Object中会存储有变量和函数，变量的值为\u0026quot;undefined\u0026quot;，函数则指向此函数所在的位置\n Reference   Understanding Execution Context and Execution Stack in Javascript JavaScript Execution Context - javatpoint  ","permalink":"https://ddinnis.github.io/posts/execution-context-scop-chain/","summary":"\u003cp\u003e这是一篇关于执行上下文(Execution Context) \u0026amp;\u0026amp; 作用域链(Scop chain)的笔记，参考了其它视频和博客资料。如有错误，欢迎指正。\u003c/p\u003e","title":"Execution Context \u0026\u0026 Scop chain"},{"content":"原型(prototype) \u0026amp;\u0026amp; 原型指针(proto)\n原型指针和原型 原型指针: __proto__  __proto__ 浏览器中显示为[[prototype]] JavaScript当中每个对象都有一个特殊的内置属性[[prototype]]，这个特殊的对象可以指向另外一个对象。指向对象的原型对象\n原型：prototype  每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。 prototype不是一个函数对象的原型。它只是一个用new关键字构造一个新的 对象的原型。\nnew操作符的执行过程  创建一个空的对象 对象的__proto__ = 构造函数的 prototype  function Person(name, age) {  this.name = name;  this.age = age; } // 通过Person构造函数创造出了对象 person1 const person1 = new Person(\u0026#34;Lily\u0026#34;, 19); const person2 = new Person(\u0026#34;Alice\u0026#34;, 22);  person1.__proto__ === person2.__proto__ // true // 对象person1 的__proto__ = 构造函数Person的 prototype person1.__proto__ === Person.prototype // true 由上图可知：person1.__proto__ === Object\nperson1.__proto__.__proto__ === Object.prototype // true constructor属性  默认情况下原型上都会有一个属性叫做constructor，constructor指向当前的函数对象本身 每创建一个函数, 就会同时创建它的prototype对象, 这个对象也会自动获取constructor属性  function Person(){} var p1 = new Person();  console.log(Person.prototype.constructor === Person) // true console.log(p1.__proto__.constructor) // [Function: Person] console.log(p1.__proto__.constructor.name) // Person  // 因为是循环引用 console.log(p1.__proto__.constructor === Person.prototype.constructor) console.log(Person.prototype === Person.prototype.constructor.prototype) 原型链(prototype chain)  JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不在该对象上搜寻 不到时，就会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾, 即最顶层null\n原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。\n 当你构造了一个对象，__proto__ 是为了在peototype chain上寻找某一方法.\nPerson.prototype.drink = \u0026#34;cola\u0026#34; 访问person1的drink属性时，person1对象没有搜寻到则搜寻person1的原型Person.prototype，匹配到了drink属性。 .valueOf 方法是Object内置方法，由原型链可在Object中搜寻到。除了.valueOf 方法外Object还有很多内置方法\nNote: 这是一张很有名的图片关于Prototype的图\nFunction.__proto__ === Object.__proto__ //true Reference:  【Just JavaScript #08】原型 Prototypes\nJavascript 原型中的哲学思想 | BlueSun (huang-jerryc.com)\nhttps://www.youtube.com/watch?v=iinGFJR6wsg\n","permalink":"https://ddinnis.github.io/posts/prototype-vs-__proto__/","summary":"\u003cp\u003e原型(prototype) \u0026amp;\u0026amp; 原型指针(\u003cstrong\u003eproto\u003c/strong\u003e)\u003c/p\u003e","title":"Prototype vs __Proto__"},{"content":"对数组进行去重\n1、Reduce() 方法\nlet myArray = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;d\u0026#39;] let myArrayWithNoDuplicates = myArray.reduce( (previousValue, currentValue) =\u0026gt; {  if (previousValue.indexOf(currentValue) === -1) {  previousValue.push(currentValue)  }  return previousValue }, []) console.log(myArrayWithNoDuplicates) //output：[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39; ] 2、利用 Set()  中元素是唯一的特点\narrayWithNoDuplicates = Array.from(new Set(myArray)) console.log(arrayWithNoDuplicates) //output：[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39; ] console.log([...new Set(myArray)]) //output：[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39; ] ","permalink":"https://ddinnis.github.io/posts/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","summary":"\u003cp\u003e对数组进行去重\u003c/p\u003e","title":"数组去重"}]