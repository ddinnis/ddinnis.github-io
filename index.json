[{"content":"Tenzies GITHUB: https://github.com/ddinnis/tenzies\n 这是一个 Demo   FreeCodeCamp GITHUB: https://github.com/ddinnis/freecodecamp\n Tribute Page Survey Form Product Landing Page Technical Documentation Page Personal Portfolio   Web Development Bootcamp by Angela GITHUB: https://github.com/ddinnis/Web-Development-Bootcamp-by-Angela\n Dicee Drum Kit My Site TinDog  ","permalink":"https://ddinnis.github.io/projects/","summary":"Tenzies GITHUB: https://github.com/ddinnis/tenzies 这是一个 Demo FreeCodeCamp GITHUB: https://github.com/ddinnis/freecodecamp Tribute Page Survey Form Product Landing Page Technical Documentation Page Personal Portfolio Web Development Bootcamp by Angela GITHUB: https://github.com/ddinnis/Web-Development-Bootcamp-by-Angela Dicee Drum Kit My Site TinDog","title":"Projects 🤹‍♂️"},{"content":"原型(prototype) \u0026amp;\u0026amp; 原型指针(proto)\n##原型指针and原型 原型指针：__proto__ 浏览器中显示为[[prototype]] 指向对象的原型对象\n原型：prototype\n 每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。 prototype不是一个函数对象的原型。它只是一个用new关键字构造一个新的 对象的原型。\nfunction Person(name, age) {  this.name = name;  this.age = age; }  const person1= new Person(\u0026#34;Lily\u0026#34;, 19);  person1.__proto__ === Person.prototype//true person1.__proto__.__proto__ === Object.prototype//true person1.prototype === undefined  原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。\n 原型链(prototype chain)\n JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾, 即最顶层null\n 当你构造了一个对象，__proto__ 是为了在peototype chain上寻找某一方法.\nPerson.prototype.drink = \u0026#34;cola\u0026#34; 访问person1的drink属性时，person1对象没有搜寻到则搜寻person1的原型Person.prototype，匹配到了drink属性。 .valueOf 方法是Object内置方法，由原型链可在Object中搜寻到。\n构造函数 (Constructor)\n每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。\nperson1.constructor === Person //true  Person.constructor.prototype === Person.__proto__ //true NOTE:\nFunction.__proto__ === Object.__proto__ //true ","permalink":"https://ddinnis.github.io/posts/prototype-vs-__proto__/","summary":"\u003cp\u003e原型(prototype) \u0026amp;\u0026amp; 原型指针(\u003cstrong\u003eproto\u003c/strong\u003e)\u003c/p\u003e","title":"Prototype vs __Proto__"},{"content":"对数组进行去重\n1、Reduce() 方法\nlet myArray = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;d\u0026#39;] let myArrayWithNoDuplicates = myArray.reduce( (previousValue, currentValue) =\u0026gt; {  if (previousValue.indexOf(currentValue) === -1) {  previousValue.push(currentValue)  }  return previousValue }, []) console.log(myArrayWithNoDuplicates) //output：[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39; ] 2、利用 Set()  中元素是唯一的特点\narrayWithNoDuplicates = Array.from(new Set(myArray)) console.log(arrayWithNoDuplicates) //output：[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39; ] console.log([...new Set(myArray)]) //output：[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39; ] ","permalink":"https://ddinnis.github.io/posts/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","summary":"\u003cp\u003e对数组进行去重\u003c/p\u003e","title":"数组去重"}]