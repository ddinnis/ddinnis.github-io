[{"content":"Tenzies GITHUB: https://github.com/ddinnis/tenzies\n 这是一个 Demo   FreeCodeCamp GITHUB: https://github.com/ddinnis/freecodecamp\n Tribute Page Survey Form Product Landing Page Technical Documentation Page Personal Portfolio   Web Development Bootcamp by Angela GITHUB: https://github.com/ddinnis/Web-Development-Bootcamp-by-Angela\n Dicee Drum Kit My Site TinDog  ","permalink":"https://ddinnis.github.io/projects/","summary":"Tenzies GITHUB: https://github.com/ddinnis/tenzies 这是一个 Demo FreeCodeCamp GITHUB: https://github.com/ddinnis/freecodecamp Tribute Page Survey Form Product Landing Page Technical Documentation Page Personal Portfolio Web Development Bootcamp by Angela GITHUB: https://github.com/ddinnis/Web-Development-Bootcamp-by-Angela Dicee Drum Kit My Site TinDog","title":"Projects 🤹‍♂️"},{"content":" 函数在调用时，JavaScripts会默认给this绑定一个值； this的绑定和定义的位置无关； this的绑定和调用方式以及调用的位置有关； this是在运行时被绑定的；  this的绑定方式:  默认绑定：通过函数进行调用，是独立函数，则this指向全局(global/window) 隐式绑定：通过方法进行调用，则this绑定到了所调用的对象上 显示绑定：可以指定绑定对象（bind call apply） 箭头函数（Arrow Function） 构造函数（new）  默认绑定  function foo() {  console.log(this) }  foo()//window 隐式绑定 var obj = {  name: \u0026#34;obj\u0026#34;,  foo: foo } function foo() {  console.log(this) }  obj.foo()//obj foo()绑定在obj对象上，this指向obj\nExample Code 1 function app(){  console.log(this)  this.appVaribale = \u0026#39;hello\u0026#39; }  app() //Window console.log(appVaribale) //hello console.log(app.appVaribale) //underfind ,appVaribale绑定到了window上 console.log(this) //window 调用app函数时，this指向window，运行 console.log(appVaribale) 代码时window增加了appVaribale对象，且值为 \u0026ldquo;hello\u0026rdquo;。与app函数无关，所以运行 console.log(app.appVaribale) 这行代码时JS引擎在app函数里面找不到appVaribale对象，则返回 undefined。\n显示绑定   bind: function.bind(thisArg[, arg1[, arg2[, ...]]])\n  call: function*.call(thisArg, arg1, arg2, ...)\n  apply: func*.apply(thisArg, [argsArray])\n  apply/call/bind: 当传入 null/undefined 时，自动将 this 绑定成全局对象\n  function add(c, d) {  console.log(this.a + this.b + c + d); } var num = {a: 1, b: 3};  add.call(num, 5, 7); // 16 add.apply(num, [10, 20]); // 34  add.call(undefined, 5, 7); // 16 add.apply(null, [10, 20]); // 34 箭头函数 箭头函数没有自己的this，都是从ParentScope继承的\nvar title = \u0026#34;window\u0026#34; const video = {  title: \u0026#39;a\u0026#39;,  play: function() {  return () =\u0026gt; {  console.log(this.title)  }  } };  var fn1 = video.play(); fn1()//a  var fn2 = video.play; fn2()()//window  调用video.play函数赋值给了fn1，fn1是一个箭头函数\n() =\u0026gt; { console.log(this.title) } ，这个箭头函数的this是从ParentScope 处继承来的，video.tilte = \u0026ldquo;a\u0026rdquo;。 引用video.plya函数，fn2是一个匿名函数调用后返回一个箭头函数\n () { return () =\u0026gt; { console.log(this.title) } }，调用箭头函数后，this指向window,因为它从上层作用域 play 继承了this。  构造函数（new） this 被绑定到正在构造的新对象\nfunction Video(title) {  console.log(this)  this.title = title }  var video = new Video(\u0026#34;a\u0026#34;) 绑定优先级 new绑定 \u0026gt; 显示绑定(bind()\u0026gt;call() / apply()) \u0026gt; 隐式绑定(obj.foo()) \u0026gt;默认绑定（独立函数调用）\n练习题  Reference  MDN | this\n深入理解js this绑定\n跟着coderwhy学习JavaScript高级（四）\n ","permalink":"https://ddinnis.github.io/posts/this/","summary":"函数在调用时，JavaScripts会默认给this绑定一个值； this的绑定和定义的位置无关； this的绑定和调用方式以及调用的位置有关；","title":"this"},{"content":"这是一篇关于执行上下文(Execution Context) \u0026amp;\u0026amp; 作用域链(Scop chain)的笔记，参考了其它视频和博客资料。如有错误，欢迎指正。\nExecution Contest 词法环境(Lexical environment) 有两个功能：\n  环境记录 (environment record) : 储存变量和函数声明\n 是一种 标识符-变量映射(identifier-variable mapping) 的结构。  标识符：变量/函数（variable/function）的名称 变量：是对对象（object）或原始值（primitive）的引用。\n比如：  var apple = 10; var banana = 20;     指向外界: outer (reference to the outer(parent) environment)\n  变量环境(Variable environments)  The LexicalEnvironment and VariableEnvironment components of an execution context are always Lexical Environments. When an execution context is created its LexicalEnvironment and VariableEnvironment components initially have the same value. The value of the VariableEnvironment component never changes while the value of the LexicalEnvironment component may change during execution of code within an execution context.\n https://262.ecma-international.org/5.1/#sec-10.3\n从中可知LexicalEnvironment 和 VariableEnvironment指向的都是Lexical Environments。\n执行上下文(Execution context)  就是执行JavaScript代码的环境  执行上下文的种类：  全局执行上下文（Global Execution Context / GEC / Default Context）  最基本的Excution Context，且只有一个 当代码加载时，默认进入的执行环境 创建一个内存堆来存储variables和function的引用地址 variables的最初值皆为”undefined”   函数执行上下文（Functional Execution Context/FEC）  可以有多个 每当调用一个函数时，会新建一个函数执行上下文。   Eval Execution Context  Eval函数很少被使用，也是执行上下文的一部分    执行堆栈 (Execution Stack)  堆栈是存储以后进先出（LIFO）形式的值的数据结构 每当调用一个新的函数时，就会新建一个Execution Context放到Execution Context Stack的顶端   作用域链（The Scope Chain） 当JS引擎在自己的环境里找不到所要的变量时，就会在外界环境（outer environment）中寻找，也就是图中的outer, 直到找到为止。由前面可知，词法环境中的 标识符-变量映射(identifier-variable mapping)\n 找到 identifier，则返回值或引用，若没有赋值就返回 undefined 未找到 identifier，则返回报错并打印Uncaught ReferenceError: \u0026lt;identified\u0026gt; is not defined   Example Code Example 1 var apple = 10; var banana = 20;  function foo() {  console.log(\u0026#39;foo\u0026#39;); }  function bar() { \tvar num = 3  console.log(\u0026#39;bar\u0026#39;); \tfoo() }  bar() //Output: //bar //foo 对于变量来说，在编译的时候JS引擎会会将变量的值初始化为“undefined”，直到开始执行到变量值的那一行代码，才会将真正的值赋值给变量\nCode Example 2 function b(){  var myvar  console.log(myvar) }  function a(){  var myvar = 2  console.log(myvar)  b() } var myvar = 1 console.log(myvar) a() console.log(myvar) 编译的时候，Global Object中会存储有变量和函数，变量的值为\u0026quot;undefined\u0026quot;，函数则指向此函数所在的位置\n Reference   Understanding Execution Context and Execution Stack in Javascript JavaScript Execution Context - javatpoint  ","permalink":"https://ddinnis.github.io/posts/execution-context-scop-chain/","summary":"\u003cp\u003e这是一篇关于执行上下文(Execution Context) \u0026amp;\u0026amp; 作用域链(Scop chain)的笔记，参考了其它视频和博客资料。如有错误，欢迎指正。\u003c/p\u003e","title":"Execution Context \u0026\u0026 Scop chain"},{"content":"原型(prototype) \u0026amp;\u0026amp; 原型指针(proto)\n原型指针和原型 原型指针: __proto__  __proto__ 浏览器中显示为[[prototype]] 指向对象的原型对象\n原型：prototype  每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。 prototype不是一个函数对象的原型。它只是一个用new关键字构造一个新的 对象的原型。\nfunction Person(name, age) {  this.name = name;  this.age = age; }  const person1= new Person(\u0026#34;Lily\u0026#34;, 19);  person1.__proto__ === Person.prototype//true person1.__proto__.__proto__ === Object.prototype//true person1.prototype === undefined  原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。\n 原型链(prototype chain)  JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾, 即最顶层null\n 当你构造了一个对象，__proto__ 是为了在peototype chain上寻找某一方法.\nPerson.prototype.drink = \u0026#34;cola\u0026#34; 访问person1的drink属性时，person1对象没有搜寻到则搜寻person1的原型Person.prototype，匹配到了drink属性。 .valueOf 方法是Object内置方法，由原型链可在Object中搜寻到。\n构造函数 (Constructor)** 每个实例对象都从原型中继承了一个constructor属性，该属性指向了用于构造此实例对象的构造函数。\nperson1.constructor === Person //true  Person.constructor.prototype === Person.__proto__ //true NOTE:\nFunction.__proto__ === Object.__proto__ //true Reference:  【Just JavaScript #08】原型 Prototypes\nJavascript 原型中的哲学思想 | BlueSun (huang-jerryc.com)\nhttps://www.youtube.com/watch?v=iinGFJR6wsg\n","permalink":"https://ddinnis.github.io/posts/prototype-vs-__proto__/","summary":"\u003cp\u003e原型(prototype) \u0026amp;\u0026amp; 原型指针(\u003cstrong\u003eproto\u003c/strong\u003e)\u003c/p\u003e","title":"Prototype vs __Proto__"},{"content":"对数组进行去重\n1、Reduce() 方法\nlet myArray = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;d\u0026#39;] let myArrayWithNoDuplicates = myArray.reduce( (previousValue, currentValue) =\u0026gt; {  if (previousValue.indexOf(currentValue) === -1) {  previousValue.push(currentValue)  }  return previousValue }, []) console.log(myArrayWithNoDuplicates) //output：[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39; ] 2、利用 Set()  中元素是唯一的特点\narrayWithNoDuplicates = Array.from(new Set(myArray)) console.log(arrayWithNoDuplicates) //output：[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39; ] console.log([...new Set(myArray)]) //output：[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39; ] ","permalink":"https://ddinnis.github.io/posts/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","summary":"\u003cp\u003e对数组进行去重\u003c/p\u003e","title":"数组去重"}]