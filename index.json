[{"content":"Crud Demo GITHUB: https://github.com/ddinnis/Vue3-CRUD-Demo\n 这是一个 Demo   Tenzies GITHUB: https://github.com/ddinnis/tenzies\n 这是一个 Demo   FreeCodeCamp GITHUB: https://github.com/ddinnis/freecodecamp\n Tribute Page Survey Form Product Landing Page Technical Documentation Page Personal Portfolio   Web Development Bootcamp by Angela GITHUB: https://github.com/ddinnis/Web-Development-Bootcamp-by-Angela\n Dicee Drum Kit My Site TinDog  ","permalink":"https://ddinnis.github.io/projects/","summary":"Crud Demo GITHUB: https://github.com/ddinnis/Vue3-CRUD-Demo 这是一个 Demo Tenzies GITHUB: https://github.com/ddinnis/tenzies 这是一个 Demo FreeCodeCamp GITHUB: https://github.com/ddinnis/freecodecamp Tribute Page Survey Form Product Landing Page Technical Documentation Page Personal Portfolio Web Development Bootcamp by Angela GITHUB: https://github.com/ddinnis/Web-Development-Bootcamp-by-Angela Dicee Drum Kit My Site TinDog","title":"Projects 🤹‍♂️"},{"content":"","permalink":"https://ddinnis.github.io/posts/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/","summary":"","title":"水平垂直居中"},{"content":"由于JavaScript的语言特性：\n 单线程（single threaded） 同步执行（Synchronously executed）  但在有的时候需要JavaScript进行异步执行代码，ES6给出的解决方法是Promise。\nPromise的基本介绍： promise翻译成中文有‘承诺’的意思，意思给你一个承诺，后期可能会实现承诺也可能会没用实现承诺。\npromise有三种状态：\n 待定（ pending ） : 初始状态，既没有被兑现，也没有被拒绝 已实现（ fulfilled ） : 意味着操作已经完成 resolve 已拒绝 （rejected）：意味着操作失败 reject  从图中我们可以清楚的看出promise三种状态之间的关系：\n  成功 (fulfilled) ⇒ 调用resolve , 会执行Promise对象的then方法传入回调函数\n  失败 (rejected) ⇒ 调用reject , 会执行Promise对象的catch方法传入回调函数\n  Promise 的状态一旦被确定下来，无法被更改，resolve、reject两个函数不会代码禁止向下执行，为了防止继续向下执行，所以要加上return。\nthen()方法返回一个 promise。接受两个参数：Promise 的成功(reslove)和失败(reject)情况的回调函数。\np.then(data =\u0026gt; {  // fulfill }, err =\u0026gt; {  // reject }); 又由于then和catch方法都会返回 promise，可以被链式调用\n链式调用 Promise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise，并且是一个全新的 Promise，原因也是因为状态不可变。如果你在 then 中 使用了 return，那么 return 的值会被 Promise.resolve()或者Promise.reject() 包装\nPromise.resolve(1)  .then(res =\u0026gt; {  console.log(res) // =\u0026gt; 1  return 2 // 包装成 Promise.resolve(2)  })  .then(res =\u0026gt; {  console.log(res) // =\u0026gt; 2  }) 举一个小例子 function foo(url) {  return new Promise((resolve, reject) =\u0026gt; {  // 假设这是网络请求,需要请求完毕才能返回给用户使用  setTimeout(() =\u0026gt; {  if (url === \u0026#39;success\u0026#39;) {  resolve({ code: \u0026#39;200\u0026#39;, message: \u0026#39;请求成功\u0026#39; })  }  if (url === \u0026#39;failure\u0026#39;) {  reject({ code: \u0026#39;-200\u0026#39;, message: \u0026#39;请求失败\u0026#39; })  }  }, 1000)  }).then(data =\u0026gt; {  console.log(data);  }).catch(err =\u0026gt; {  console.log(err);  }) } foo(\u0026#39;success\u0026#39;) foo(\u0026#39;failure\u0026#39;) 当foo()函数传入的是success值时，pedding状态转化为fullfill，会调用resolve执行Promise对象的then方法传入回调函数，最后打印出{ code: '200', message: '请求成功' }\n当foo()函数传入的是failure值时，pedding状态转化为reject，会调用resolve执行Promise对象的catch方法传入回调函数，最后打印出{ code: '-200', message: '请求失败' }\n","permalink":"https://ddinnis.github.io/posts/promise/","summary":"由于JavaScript的语言特性： 单线程（single threaded） 同步执行（Synchronously executed） 但在有的时候","title":"Promise"},{"content":"JS是单线程语言 JS是一种单线程（single thread）语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，从上往下一行一行进行执行，否则会带来很复杂的同步问题。\n JS是单线程语言，只能同时做一件事儿  异步不会阻塞代码执行 同步会阻塞代码执行   JS和DOM渲染共用同一个线程，因为JS可修改DOM结构 DOM事件也使用回调，基于event loop  Event loop 由图所知 event loop 是由 JS RunTime（主线程）、Web Apis （外部API）以及 Callback Queue（任务队列） 组成的。\n stack：用于分配原始类型 heap：用于分配对象类型 queue：先进先出，排在前面的事件，优先被处理。  同步代码，一行一行放在主线程执行，会将不同类型的数据保存到堆和栈中。遇到异步也就是调用各种不同的Web Apis，会先“记录”下，等待时机(定时、网络请求等)。时机到了，就添加到到Callback Queue。如主线程为空（即同步代码执行完）Event Loop开始工作，循环查找Callback Queue，如有则移动到主线程执行，然后继续循环查找。\n宏任务微任务 任务队列有宏任务和微任务之分：\n  宏任务队列（macro task queue）：script(整体代码)，ajax、setTimeout、setInterval、DOM监听、UI Rendering 等\n  微任务队列（micro task queue）：Promise 的 then 回调、 Mutation Observer API、queueMicrotask() 等\n  事件循环执行的优先级：主程序 —\u0026gt; 微任务 —\u0026gt; 宏任务\n1、main script 中的代码优先执行（编写的顶层script代码）；\n2、先执行微任务，当微任务队列为空后再执行宏任务\n举个例子 async function async1 () {  console.log(\u0026#39;async1 start\u0026#39;)  await async2();  console.log(\u0026#39;async1 end\u0026#39;) // 加入到微任务队列 }  async function async2 () {  // return undefined --\u0026gt; new Promise，因为async 函数返回一定是个 promise  console.log(\u0026#39;async2\u0026#39;) }  console.log(\u0026#39;script start\u0026#39;)  setTimeout(function () {  console.log(\u0026#39;setTimeout\u0026#39;) }, 0)  async1();  new Promise (function (resolve) {  console.log(\u0026#39;promise1\u0026#39;)  resolve(); }).then (function () {  console.log(\u0026#39;promise2\u0026#39;) })  console.log(\u0026#39;script end\u0026#39;) // script start // async1 start // async2 // promise1 // script end // async1 end // promise2 // setTimeout 先执行 script （整体代码），第一步执行console.log('script start')，asycn1() 函数和async2()函数只是已定义但还没声明，所以先不管它们。console.log('script start')执行完后将跳出函数执行栈。\n遇到了setTimeout函数，进入marco task 队列：\n然后执行async1()函数，打印 'async1 start' 将 await 后面的代码 console.log('async1 end') 加入到 micro task队列中\n执行async2()函数，打印 'async2' 后再执行 promise 函数\n再执行promise函数后会打印 promise1，后 promise 状态转变为 resolve，将console.log('promise2')加入micro task 队列。最后再执行 console.log('script end')\n至此主程序执行完毕，就先执行micro task 队列里的函数，主程序执行完毕后，再执行macro task 队列里的函数。\nPS：零延迟 当 setTimeout 函数的 delay 为零的时候并不意味着回调会立即执行。其等待的时间取决于队列里待处理的消息数量。因为只有队列里的所有任务都处理完后才会处理 setTimeout 函数。\nReference  JavaScript 运行机制详解：再谈Event Loop - 阮一峰的网络日志 (ruanyifeng.com)\nThe event loop - JavaScript | MDN (mozilla.org)\n前端基础进阶（十二）：深入核心，详解事件循环机制 - SegmentFault 思否\n ","permalink":"https://ddinnis.github.io/posts/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AFevent-loop/","summary":"JS是单线程语言 JS是一种单线程（single thread）语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能","title":"事件循环(event loop)"},{"content":"在操作如何用 Git 上传管理代码至 GitHub 时常常用到的命令，当时只知道照着网站上的步骤一步一步敲命令行，但不知其所以然，所以用这篇文章记录一下笔记。\n1、Git的文件状态 在用 Git 管理一个仓库的时候，会对文件有不同的状态划分，以确定这个文件是否已经归于Git仓库的管理，文件状态分为两种：未跟踪状态（untracked）和已跟踪状态（tracked）\n 未跟踪：默认情况下， Git仓库下的文件没有添加到Git仓库管理中  staged：暂缓区中的文件状态，可以通过add .命令将文件添加到暂存区 Unmodified： 通过commit命令，可以将staged中文件提交到Git仓库 Modified：修改了某个文件后，会处于Modified状态；   已跟踪：添加到Git仓库管理的文件处于已跟踪状态， Git可以对其进行各种跟踪管理  下面这张图可以很好的展示它门之间的关系以及变化：\n2、常用的代码 在了解了文件状态之后，再看一下我常用的代码：\ngit init git remote add origin https://github.com/xx/xx.git git add . git commit -m \u0026#34;your commit\u0026#34; git push -u origin main  git init  ​\t是对本地的代码仓库进行初始化，但如果想获取其它地方的仓库则用 git clone https://github.com/xx/xx.git\n git remote add origin https://github.com/xx/xx.git  ​\t链接远程仓库，origin就是一个名称，在你clone一个代码库时，git为你默认创建的指向这个远程代码库的标签\n git add .  ​\t表示将所有文件添加到暂存区，注意add 和 . 之间需要加空格。如果是git add a.js 则表示只将 a.js 这个文件添加到暂存区。\n git commit -m \u0026ldquo;your commit\u0026rdquo;   Git 在储存数据时，所有的对象都会基于它们的SHA-1 hash进行寻址。\n ​\t文件更新提交，再每次准备提交前，先用 git status 看下，你所需要的文件是不是都已暂存起来了，再运行提交命令 git commit。也可以将git add . 和 git commit -m'' 两行命令合并为 git -a -m ''\n git push -u origin main  ​\t默认情况下是将当前分支（这里是main） push 到 origin 远程仓库； -u 是将本地的分支版本上传到远程合并，并且记录push到远程分支的默认值，下次继续push的这个远端分支的时候推送命令就可以简写成“git push”。\n git push / git push origin master  ​\t将代码push到远程仓库：将本地仓库的代码当前分支推送到远程仓库中；\n git fetch / git fetch origin  ​\t从远程仓库fetch代码：从远程仓库获取最新的代码\n git merge  ​\t获取到代码后默认并没有合并到本地仓库，我们需要通过merge来合并\n git pull  ​\t从远程仓库pull代码 = git fetch + git merge(rebase)\n3、Git其它强大的功能 查看提交的历史\ngit log --pretty=oneline git log --pretty=oneline --graph git reflog // 所有详细操作 版本回退\ngit reset --hard HEAD^ // 上个版本 git reset --hard HEAD~n // 上n个版本 git reset --hard 2d44982 // 指定某个版本的commit id \u0026hellip;\u0026hellip;\n","permalink":"https://ddinnis.github.io/posts/git%E6%9C%89%E5%85%B3%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","summary":"在操作如何用 Git 上传管理代码至 GitHub 时常常用到的命令，当时只知道照着网站上的步骤一步一步敲命令行，但不知其所以然，所以用这篇文章记录一下笔记。 1、","title":"Git有关常用命令"},{"content":"定义  一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。\n闭包：函数 + 可以访问的自由变量\n  普通函数：如果它可以访问外层作用于的自由变量，那么这个函数就是一个闭包；\n广义的角度：JavaScript中的函数都是闭包；\n狭义的角度：JavaScript中一个函数，如果访问了外层作用于的变量，那么它是一个闭包；\n​\t出自于 coderwhy 大佬\n 作用： 1、实现数据私有 let count = 0 function fn () {  count++  console.log(\u0026#39;fn函数被调用了\u0026#39; + count + \u0026#39;次\u0026#39;) } fn() // count数据容易被修改 fn() fn() count = 10 fn() // fn函数被调用了11次  -------------------------------------------------------------  function fn () {  let count = 0  function add () {  count++  console.log(\u0026#39;fn函数被调用了\u0026#39; + count + \u0026#39;次\u0026#39;)  }  return add } const addFn = fn() addFn() // fn函数被调用了1次 addFn() // fn函数被调用了2次 addFn() // fn函数被调用了3次 count = 10 addFn() // fn函数被调用了4次 2、解决 var 的全局变量在异步函数调用中的变化 for (**let** i = 0; i \u0026lt; 5; i++) { // let 是局部变量  setTimeout(() =\u0026gt; {  console.log(i);  }, 1000 * i); } //输出：0 1 2 3 4  for (**var** i = 0; i \u0026lt; 5; i++) { // var 是全局变量  setTimeout(() =\u0026gt; {  console.log(i);  }, 1000 * i); } // 输出： 5 5 5 5 5，5是因为最后i++跳出来的是5  // 使用闭包实现类似let的结果 for (var i = 0; i \u0026lt; 5; i++) {  function f(i) {  setTimeout(() =\u0026gt; {  console.log(i);  }, 1000 * i);  }  f(i); } //输出：0 1 2 3 4 3、让这些变量的值始终保持在内存中，不被销毁 注意点：外部函数中，一般需要return来进行引用（内存才不会被释放）\n销毁的方法：\n 标记清除：从根部，全局出发，访问不到（无法触及）的内存空间，就会被自动回收 释放内存，断开了对于之前内部函数的引用，对应的缓存的变量内容也会被释放掉  Reference  你不可不知道的 JavaScript 作用域和闭包 - 知乎 (zhihu.com)\n学习Javascript闭包（Closure） - 阮一峰的网络日志 (ruanyifeng.com)\njavasctipt.info | Variable scope, closure\nJavaScript深入之闭包 #9\n ","permalink":"https://ddinnis.github.io/posts/%E9%97%AD%E5%8C%85closure/","summary":"定义 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（c","title":"闭包(closure)"},{"content":"JavaScript目前有三个关键字来声明变量，即var, let, const。 在ES6之前只有一种方法 var 来申明变量，ES6后新添了 let 和 const 声明变量。\nVar (global and function scope):  全局作用域，会在window上添加属性 可以再次声明 可以重新赋值 在函数内定义时，作用域是函数内部，在函数外定义时，作用域为全局 在任何变量被执行前，会对var进行变量提升（hosting），初始值为 undefined   变量提升（hosting）：意味着可以在定义一个变量在未声明前\n // 全局作用域  var name = \u0026#34;John Doe\u0026#34;; function logName() {  console.log(name); };  logName(); // John Doe // Window {window: Window, self: Window, document: document, name: \u0026#39;John Doe\u0026#39;, location: Location, …} // 在函数内定义时，作用域是函数内部  function logName() {  var name = \u0026#34;John Doe\u0026#34;;  var id = 1;  console.log(name); };  function logId() {  console.log(id); }  logId(); // ReferenceError: id is not defined // 在执行logId函数的时候，id没有在logId函数内定义 // 所以在全局变量中寻找id变量，也没有 // 所以是undefined // 在函数外定义时，作用域为全局  var name = \u0026#34;John Doe\u0026#34;; if (true) {  var name = \u0026#34;Daniel Joan\u0026#34;; }  console.log(name); // Daniel Joan // 当在{}大括号中定义var时 // name的值会被重写，指向\u0026#34;Daniel Joan\u0026#34; // 变量提升  function logName() {  console.log(name);  var name = \u0026#34;John Doe\u0026#34;; };  logName(); // undefined let (block scope) 和 const (block scope)：  只有块级作用域，window无法访问 不可以再次声明 在变量声明之前，变量都是不可以访问的 不存在变量提升（解析阶段会被创建出来，但不能被访问）  二者的区别是：\n 需要重新分配变量的时候使用 let，例如：循环\n  不需要重新分配变量的时候使用 const，是constant（常数）的缩写 但是可以改变const对象的属性\n let name = \u0026#34;John\u0026#34;;  if(true){  let name = \u0026#34;Jane\u0026#34;;  console.log(name); }  console.log(name); // Jane // John // 这两个name变量是不同的变量，因为有着不同的作用域  function fn() {  if(true){  let name = \u0026#34;Jane\u0026#34;;  console.log(name);  }  console.log(name); // let是块级作用域，name在if代码块中定义 }  fn() // Jane // ReferenceError: name is not defined let 和 const是块级作用域\n{  const x = 2;  console.log(x); // 2 } console.log(x); // ReferenceError: x is not defined  {  let x = 2;  console.log(x); // 2 } console.log(x); let和const皆不可以再次声明\nlet name = \u0026#34;John\u0026#34;; let name = \u0026#34;Jane\u0026#34;; // SyntaxError: Identifier \u0026#39;name\u0026#39; has already been declared let name = \u0026#34;John\u0026#34;; name = \u0026#34;Jane\u0026#34;; // let可以重新赋值  const name = \u0026#34;John\u0026#34;; const name = \u0026#34;Jane\u0026#34;; // SyntaxError: Identifier \u0026#39;name\u0026#39; has already been declared const name = \u0026#34;John\u0026#34;; name = \u0026#34;Jane\u0026#34;; // TypeError: Assignment to constant variable. // const重新赋值不被允许 const不可以再次赋值，可以通过改变const对象的属性进行赋值\nconst fullName = {  firstName: \u0026#34;John\u0026#34;,  lastName: \u0026#34;Doe\u0026#34; } fullName.firstName = \u0026#34;Ellen\u0026#34; console.log(fullName) // { firstName: \u0026#39;Ellen\u0026#39;, lastName: \u0026#39;Doe\u0026#39; }  实际开发如何选择   首先排除var在let和const之间做选择，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。\n  在导入库（Libraries）的时候使用const\n  一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提高程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同.\n  Reference   The Difference Between var, let and const in JavaScript and Best Practices educative | Difference between var, let, and const keyword in JavaScript geeksforgeeks | Difference between var, let and const keywords in JavaScript On let vs const   ","permalink":"https://ddinnis.github.io/posts/varlet-and-const/","summary":"JavaScript目前有三个关键字来声明变量，即var, let, const。 在ES6之前只有一种方法 var 来申明变量，ES6后新添了 let 和 const 声明变量。","title":"var，let and const"},{"content":"1、\nvar x = 10; var obj = {  x: 20,  f: function(){  console.log(this.x); // ?  var foo = function(){  console.log(this.x);  }  foo(); // ?  } }; obj.f();  obj.f() 执行的时候很明显是默认绑定，绑定到了obj上。\\ 执行foo() 的时候前面没有任何东西，显然是默认绑定。\n答案为：20 10   var x = 10; var obj = {  x: 20,  f: function(){ console.log(this.x); } }; var bar = obj.f; var obj2 = {  x: 30,  f: obj.f } obj.f(); //20 bar(); //10 obj2.f();//30  执行obj.f()是隐式绑定，this指向obj的x 执行bar()是显式绑定，this指向window的x 执行obj2.f()是隐式绑定，this指向obj2的x\n答案为：20 10 30   function foo() {  getName = function () { console.log (1); };  return this; }  foo.getName = function () { console.log(2);}; foo.prototype.getName = function () { console.log(3);}; var getName = function () { console.log(4);}; function getName () { console.log(5);}  foo.getName (); // ? 2 getName (); // ? 4 foo().getName (); // ? getName (); // ? 5 new foo.getName (); // ? 1 new foo().getName (); // ? new new foo().getName (); // ? ","permalink":"https://ddinnis.github.io/posts/this%E4%B9%A0%E9%A2%98/","summary":"1、 var x = 10; var obj = { x: 20, f: function(){ console.log(this.x); // ? var foo = function(){ console.log(this.x); } foo(); // ? } }; obj.f(); obj.f() 执行的时候很明显是默认绑定，绑定到了obj上。\\ 执行foo() 的时候前面没有任何","title":"this习题"},{"content":" 函数在调用时，JavaScripts会默认给this绑定一个值； this的绑定和定义的位置无关； this的绑定和调用方式以及调用的位置有关； this是在运行时被绑定的；  this的绑定方式:  默认绑定：通过函数进行调用，是独立函数，则this指向全局(global/window) 隐式绑定：通过方法进行调用，则this绑定到了所调用的对象上 显示绑定：可以指定绑定对象（bind call apply） 箭头函数（Arrow Function） 构造函数（new）  默认绑定  function foo() {  console.log(this) }  foo()//window 隐式绑定 var obj = {  name: \u0026#34;obj\u0026#34;,  foo: foo } function foo() {  console.log(this) }  obj.foo()//obj foo()绑定在obj对象上，this指向obj\nExample Code 1 function app(){  console.log(this)  this.appVaribale = \u0026#39;hello\u0026#39; }  app() //Window console.log(appVaribale) //hello console.log(app.appVaribale) //underfind ,appVaribale绑定到了window上 console.log(this) //window 调用app函数时，this指向window，运行 console.log(appVaribale) 代码时window增加了appVaribale对象，且值为 \u0026ldquo;hello\u0026rdquo;。与app函数无关，所以运行 console.log(app.appVaribale) 这行代码时JS引擎在app函数里面找不到appVaribale对象，则返回 undefined。\n显示绑定   bind: function.bind(thisArg[, arg1[, arg2[, ...]]])\n  call: function*.call(thisArg, arg1, arg2, ...)\n  apply: func*.apply(thisArg, [argsArray])\n  apply/call/bind: 当传入 null/undefined 时，自动将 this 绑定成全局对象\n  function add(c, d) {  console.log(this.a + this.b + c + d); } var num = {a: 1, b: 3};  add.call(num, 5, 7); // 16 add.apply(num, [10, 20]); // 34  add.call(undefined, 5, 7); // 16 add.apply(null, [10, 20]); // 34 箭头函数 箭头函数没有自己的this，都是从ParentScope继承的\nvar title = \u0026#34;window\u0026#34; const video = {  title: \u0026#39;a\u0026#39;,  play: function() {  return () =\u0026gt; {  console.log(this.title)  }  } };  var fn1 = video.play(); fn1()//a  var fn2 = video.play; fn2()()//window  调用video.play函数赋值给了fn1，fn1是一个箭头函数\n() =\u0026gt; { console.log(this.title) } ，这个箭头函数的this是从ParentScope 处继承来的，video.tilte = \u0026ldquo;a\u0026rdquo;。 引用video.plya函数，fn2是一个匿名函数调用后返回一个箭头函数\n () { return () =\u0026gt; { console.log(this.title) } }，调用箭头函数后，this指向window,因为它从上层作用域 play 继承了this。  构造函数（new） this 被绑定到正在构造的新对象\nfunction Video(title) {  console.log(this)  this.title = title }  var video = new Video(\u0026#34;a\u0026#34;) 绑定优先级 new绑定 \u0026gt; 显示绑定(bind()\u0026gt;call() / apply()) \u0026gt; 隐式绑定(obj.foo()) \u0026gt;默认绑定（独立函数调用）\n练习题 习题来自于： 跟着coderwhy学习JavaScript高级（四） - 掘金 (juejin.cn)\nvar name = \u0026#34;window\u0026#34; var person = {  name: \u0026#34;person\u0026#34;,  sayName: function () {  console.log(this.name)  } };  function sayName() {  var sss = person.sayName;  sss() //window  person.sayName(); //person  (person.sayName)(); //My Mistake === person.sayName();  (b = person.sayName)(); //window }  sayName()  sss() : person.sayName为function () {console.log(this.name)} 赋值给 sss ,当调用 sss 函数时, 相当于函数独立调用(默认绑定), 指向window person.sayName() : 通过person调用(隐式绑定) (person.sayName)() : 等价于person.sayName() ,与sss() 不同的是, person.sayName 赋值给了新的变量sss . (b = person.sayName)() : 等价于sss()   var name = \u0026#34;window\u0026#34; var person1 = {  name: \u0026#34;person1\u0026#34;,  foo1: function () {  console.log(this.name)  },  foo2: () =\u0026gt; console.log(this.name),  foo3: function() {  return function() {  console.log(this.name)  }  },  foo4: function() {  return () =\u0026gt; {  console.log(this.name)  }  } };  var person2 = {name: \u0026#39;person2\u0026#39;}  person1.foo1(); //person1 person1.foo1.call(person2) //person2  person1.foo2(); //window,上层作用域是全局 person1.foo2.call(person2) //window foo2为箭头函数优先级\u0026gt;call/bind/apply  person1.foo3()(); //window独立函数调用，(person.foo3())() person1.foo3.call(person2)() //window person1.foo3().call(person2) //person2  person1.foo4()(); //person1,返回的箭头函数指向上层foo4函数指向person1 person1.foo4.call(person2)() //person2 person1.foo4().call(person2) //person1 person1.foo1() : 隐式绑定 person1.foo1.call(person2) : 显示绑定, 通过 call() 绑定到了person2上\nperson1.foo2() : 箭头函数要注意, 箭头函数本身没有 this 值, this值是从上层作用域(parentScope)继承而来的, foo2的上层作用域是window.\n 💡 注意person1 是一个对象而非函数, 所以foo2 的上层作用域不是person1\n person1.foo2.call(person2) : 箭头函数优先级 \u0026gt; 显示绑定( call/bind/apply )\nperson1.foo3()() : 等价于(person1.foo3())() , 独立函数调用(默认绑定) person1.foo3.call(person2)() : 等价于 (person1.foo3.call(person2))() , 独立函数调用(默认绑定) person1.foo3().call(person2) : 最后调用的函数绑定到了person2(显示绑定)\nperson1.foo4()() : 返回的箭头函数指向上层 foo4 函数指向person1 person1.foo4.call(person2)() : 返回的箭头函数指向上层foo4函数指向person2 person1.foo4().call(person2) : 返回的箭头函数指向上层foo4函数指向person1\n 💡 箭头函数自身没有 this 值, this值是从上层作用域(parentScope)继承而来的\n  var name = \u0026#39;window\u0026#39;  function Person(name) {  this.name = name;  this.obj = {  name: \u0026#39;obj\u0026#39;,  foo1: function () {  return function () {  console.log(this.name)  }  },  foo2: function () {  return () =\u0026gt; {  console.log(this.name)  }  }  }  }   var person1 = new Person(\u0026#39;person1\u0026#39;)  var person2 = new Person(\u0026#39;person2\u0026#39;)   person1.obj.foo1()() //window  person1.obj.foo1.call(person2)() //window  person1.obj.foo1().call(person2) //person2   person1.obj.foo2()() //obj  person1.obj.foo2.call(person2)() //person2  person1.obj.foo2().call(person2) //obj   person1.obj.foo1()() : 独立函数(默认绑定)\n  person1.obj.foo1.call(person2)() : 相当于 (person1.obj.foo1.call(person2))() 也是独立函数\n  person1.obj.foo1().call(person2) : 显示绑定, 绑定到了person2 上\n  person1.obj.foo2()() : 相当于 (person1.obj.foo2())() , 返回了一个箭头函数后调用它, 箭头函数的 this 继承于上层作用域 foo2 .\n  person1.obj.foo2.call(person2)() : 与person1.obj.foo2()() 类似, 但上层作用域 foo2 的this 被绑定到了 person1 上.\n  person1.obj.foo2().call(person2) : 返回的箭头函数指向上层 foo2 的 this 指向person2\n   Reference  MDN | this\n深入理解js this绑定\n跟着coderwhy学习JavaScript高级（四）\n ","permalink":"https://ddinnis.github.io/posts/this/","summary":"函数在调用时，JavaScripts会默认给this绑定一个值； this的绑定和定义的位置无关； this的绑定和调用方式以及调用的位置有关；","title":"this"},{"content":"这是一篇关于执行上下文(Execution Context) \u0026amp;\u0026amp; 作用域链(Scop chain)的笔记。\nExecution Context 词法环境(Lexical environment) 有两个功能：\n  环境记录 (environment record) : 储存变量和函数声明\n 是一种 标识符-变量映射(identifier-variable mapping) 的结构。  标识符(identifier)：变量/函数（variable/function）的名称 变量(value)：是对对象（object）或原始值（primitive）的引用。\\      指向外界: outer (reference to the outer(parent) environment)\nlexicalEnvironment = {  environmentRecord: {  \u0026lt;identifier\u0026gt; : \u0026lt;value\u0026gt;,  \u0026lt;identifier\u0026gt; : \u0026lt;value\u0026gt;  }  outer: \u0026lt; Reference to the parent lexical environment\u0026gt;  thisBinding：取决于运行所在地 } Code:\nvar apple = 10; function foo() {  var banana = 20;  console.log(\u0026#39;foo\u0026#39;); } foo(); GlobalLexicalEnvironment = {  environmentRecord: {  apple : \u0026#39;10\u0026#39;,  foo : \u0026lt; reference to function object \u0026gt;  }  outer: null }  FunctionLexicalEnvironment = {  environmentRecord: {  banana : 20,  }  outer: \u0026lt;globalLexicalEnvironment\u0026gt; }   变量环境(Variable environments)  The LexicalEnvironment and VariableEnvironment components of an execution context are always Lexical Environments. When an execution context is created its LexicalEnvironment and VariableEnvironment components initially have the same value. The value of the VariableEnvironment component never changes while the value of the LexicalEnvironment component may change during execution of code within an execution context.\n https://262.ecma-international.org/5.1/#sec-10.3\n从中可知LexicalEnvironment 和 VariableEnvironment指向的都是Lexical Environments。\n执行上下文(Execution context)  执行JavaScript代码的环境  执行上下文的种类：  全局执行上下文（Global Execution Context / GEC）  最基本的Excution Context，且只有一个 当代码加载时，默认进入的执行环境 创建一个内存堆来存储variables和function的引用地址 variables的最初值皆为”undefined”   函数执行上下文（Function Execution Context / FEC）  可以有多个 每当调用一个函数时，会新建一个函数执行上下文。    执行上下文分为两个阶段：   创建阶段\n  执行阶段\n创建阶段： ​\tJS Engine 会解析代码，对代码中的var变量和函数提升到代码顶层，并开辟空间进行储存，所有的var变量初始值皆为undefined，所以可以在声明之前被引用。\n​\t这就会引出变量提升(Hoisting)的问题：\nconsole.log(apple); // undefined foo(); // foo  var apple = 10; function foo() {  console.log(\u0026#39;foo\u0026#39;); } ​\tconsole.log(apple) 的结果为 undefined 就是因为变量声明，在执行第一行代码时 apple = undefined ，直到第三行 var apple = 10 时 apple 才会被赋值于10变量提升的规则：\n 作用于var，会被初始化为undefined 对于let const，不会被初始化有默认值，所以会报错: ·ReferenceError : is not defined  创建作用域链（The Scope Chain） 当JS引擎在自己的环境里找不到所要的变量时，就会在外界环境（outer environment）中寻找，也就是词法环境中的outer, 直到找到为止。但是外部作用域不能作用于内部函数\n  找到 identifier，则返回值或引用，若没有赋值就返回 undefined\n  未找到 identifier，则返回报错并打印Uncaught ReferenceError: \u0026lt;identified\u0026gt; is not defined\n  执行阶段： 执行堆栈 (Execution Stack)  堆栈是存储以后进先出（LIFO）形式的值的数据结构 当函数执行调用时，都会从堆栈中移除，但是其词法环境是否从内存中释放，取决于其是否被其它词法环境的 outer 引用 每当调用一个新的函数时，就会新建一个Execution Context放到Execution Context Stack的顶端     Example Code Example 1 var apple = 10; var banana = 20;  function foo() {  console.log(\u0026#39;foo\u0026#39;); }  function bar() { \tvar num = 3  console.log(\u0026#39;bar\u0026#39;); \tfoo() }  bar() //Output: //bar //foo 对于变量来说，在编译的时候JS引擎会会将变量的值初始化为“undefined”，直到开始执行到变量值的那一行代码，才会将真正的值赋值给变量\nCode Example 2 function b(){  var myvar  console.log(myvar) }  function a(){  var myvar = 2  console.log(myvar)  b() } var myvar = 1 console.log(myvar) a() console.log(myvar) 编译的时候，Global Object中会存储有变量和函数，变量的值为\u0026quot;undefined\u0026quot;，函数则指向此函数所在的位置\n Reference    Understanding Execution Context and Execution Stack in Javascript\n  JavaScript Execution Context - javatpoint\n  ECMAScript 5 spec: LexicalEnvironment versus VariableEnvironment\n  Understanding Scope and Scope Chain in JavaScript\n  ECMA-262-5 in detail. Chapter 3.2. Lexical environments: ECMAScript implementation.\n  ","permalink":"https://ddinnis.github.io/posts/execution-context-scop-chain/","summary":"\u003cp\u003e这是一篇关于执行上下文(Execution Context) \u0026amp;\u0026amp; 作用域链(Scop chain)的笔记。\u003c/p\u003e","title":"Execution Context \u0026\u0026 Scop chain"},{"content":"原型(prototype) \u0026amp;\u0026amp; 原型指针(proto)\n原型指针和原型 原型指针: __proto__  __proto__ 浏览器中显示为[[prototype]] JavaScript当中每个对象都有一个特殊的内置属性[[prototype]]，这个特殊的对象可以指向另外一个对象。这个属性在现在来说已经不推荐直接去使用它了，这只是浏览器在早期为了让我们访问到内部属性 [[prototype]] 来实现的一个东西。\n原型：prototype  每个对象拥有一个原型对象，对象以其原型为模板、从原型继承方法和属性。 prototype不是一个函数对象的原型。它只是一个用new关键字构造一个新的 对象的原型。\nnew操作符的执行过程  创建一个空的对象 对象的__proto__ = 构造函数的 prototype  function Person(name, age) {  this.name = name;  this.age = age; } // 通过Person构造函数创造出了对象 person1 const person1 = new Person(\u0026#34;Lily\u0026#34;, 19); const person2 = new Person(\u0026#34;Alice\u0026#34;, 22);  person1.__proto__ === person2.__proto__ // true // 对象person1 的__proto__ = 构造函数Person的 prototype person1.__proto__ === Person.prototype // true 由上图可知：person1.__proto__ === Object\nperson1.__proto__.__proto__ === Object.prototype // true constructor属性  默认情况下原型上都会有一个属性叫做constructor，constructor指向当前的函数对象本身 每创建一个函数, 就会同时创建它的prototype对象, 这个对象也会自动获取constructor属性  function Person(){} var p1 = new Person();  console.log(Person.prototype.constructor === Person) // true console.log(p1.__proto__.constructor) // [Function: Person] console.log(p1.__proto__.constructor.name) // Person  // 因为是循环引用 console.log(p1.__proto__.constructor === Person.prototype.constructor) console.log(Person.prototype === Person.prototype.constructor.prototype) 原型链(prototype chain)  JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不在该对象上搜寻 不到时，就会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾, 即最顶层null\n原型对象也可能拥有原型，并从中继承方法和属性，一层一层、以此类推。\n 当你构造了一个对象，__proto__ 是为了在peototype chain上寻找某一方法.\nPerson.prototype.drink = \u0026#34;cola\u0026#34; 访问person1的drink属性时，person1对象没有搜寻到则搜寻person1的原型Person.prototype，匹配到了drink属性。 .valueOf 方法是Object内置方法，由原型链可在Object中搜寻到。除了.valueOf 方法外Object还有很多内置方法\nNote: 这是一张很有名的图片关于Prototype的图\nFunction.__proto__ === Object.__proto__ //true Reference:  【Just JavaScript #08】原型 Prototypes\nJavascript 原型中的哲学思想 | BlueSun (huang-jerryc.com)\nhttps://www.youtube.com/watch?v=iinGFJR6wsg\n","permalink":"https://ddinnis.github.io/posts/prototype-vs-__proto__/","summary":"\u003cp\u003e原型(prototype) \u0026amp;\u0026amp; 原型指针(\u003cstrong\u003eproto\u003c/strong\u003e)\u003c/p\u003e","title":"Prototype vs __Proto__"},{"content":"对数组进行去重\n1、Reduce() 方法\nlet myArray = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;d\u0026#39;] let myArrayWithNoDuplicates = myArray.reduce( (previousValue, currentValue) =\u0026gt; {  if (previousValue.indexOf(currentValue) === -1) {  previousValue.push(currentValue)  }  return previousValue }, []) console.log(myArrayWithNoDuplicates) //output：[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39; ] 2、利用 Set()  中元素是唯一的特点\narrayWithNoDuplicates = Array.from(new Set(myArray)) console.log(arrayWithNoDuplicates) //output：[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39; ] console.log([...new Set(myArray)]) //output：[ \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39; ] ","permalink":"https://ddinnis.github.io/posts/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/","summary":"\u003cp\u003e对数组进行去重\u003c/p\u003e","title":"数组去重"}]